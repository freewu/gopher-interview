## Slice和数组的对比

```
在 Go 中，与 C 数组变量隐式作为指针使用不同，Go 数组是值类型，赋值和函数传参操作都会复制整个数组数据。

用切片传数组参数，既可以达到节约内存的目的，也可以达到合理处理好共享内存的问题。

并非所有时候都适合用切片代替数组，因为切片底层数组可能会在堆上分配内存，而且小数组在栈上拷贝的消耗也未必比 make 消耗大。
```

## Slice的底层实现

```
切片是基于数组实现的，它的底层是数组，它自己本身非常小，可以理解为对底层数组的抽象。因为基于数组实现，所以它的底层的内存是连续分配的，效率非常高，还可以通过索引获得数据，可以迭代以及垃圾回收优化。

切片本身并不是动态数组或者数组指针。它内部实现的数据结构通过指针引用底层数组，设定相关属性将数据读写操作限定在指定的区域内。切片本身是一个只读对象，其工作机制类似数组指针的一种封装。

切片对象非常小，是因为它是只有3个字段的数据结构：

    指向底层数组的指针 Array
    切片的长度 Len
    切片的容量 Cap
```

## Slice的扩容机制

```
切片扩容的策略:
	首先判断，如果新申请容量大于2倍的旧容量，最终容量就是新申请的容量
    否则判断，如果旧切片的长度小于1024，则最终容量就是旧容量的两倍
    否则判断，如果旧切片长度大于等于1024，则最终容量从旧容量开始循环增加原来的 1/4, 直到最终容量大于等于新申请的容量
    如果最终容量计算值溢出，则最终容量就是新申请容量
```

## 扩容前后的Slice是否相同

```
情况一：
原数组还有容量可以扩容（实际容量没有填充完），这种情况下，扩容以后的数组还是指向原来的数组，对一个切片的操作可能影响多个指针指向相同地址的Slice。

情况二：
原来数组的容量已经达到了最大值，再想扩容， Go 默认会先开一片内存区域，把原来的值拷贝过来，然后再执行 append() 操作。这种情况丝毫不影响原数组。

要复制一个Slice，最好使用Copy函数。
```

